<!DOCTYPE html>
<html>
  <head>
      <meta charset="UTF-8">
      <meta name="description" content="Personal Notes">
      <meta name="keywords" content="HTML,CSS,JavaScript, Secuirty, Cryptography">
      <meta name="author" content="Nan Qin">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Computer Security</title>
    <style>

      body{
        margin:0;/* body default margin is 8px */
      }



    </style>
    <link rel="stylesheet" type="text/css" href="./css/navigationbar.css">
    <link rel="stylesheet" type="text/css" href="./css/sidebar.css">
    <link rel="stylesheet" type="text/css" href="./css/content.css">
  </head>
  <body>
    <ul id="nav">
      <li><a class="active">Home</a></li><!-- remove the space between inlined elements
    --><li><a href="#1">Security</a></li><!--
    --><li><a href="#2">OS</a></li><!--
    --><li><a href="#3">Networking</a></li><!--
    --><li><a href="#3">Tools</a></li>

    </ul>



    <ul id="sidebar">
        <li><a href="#distributedsystems">Distributed Systems</a></li>
        <ol class="dropdown">
          <li><a href="#">Frameworks</a></li>
        </ol>
        <li><a href="security.html">Security</a></li>
        <ol class="dropdown">
          <li><a href="security.html#crypto">Cryptography</a></li>
        </ol>
        <li><a href="webdesign.html">Web design</a></li>
        <ol class="dropdown">
          <li><a href="webdesign.html#html">HTML</a></li>
          <li><a href="webdesign.html#css">CSS</a></li>
        </ol>
        <li><a href="#3">Web servers</a></li>
        <ol class="dropdown">
          <li><a href="#">Apache2</a></li>
        </ol>
        <li><a href="#4">Compression</a></li>
        <li><a href="#5">Multimedia streaming</a></li>
        <li><a href="#tools.html">Tools</a></li>
        <ol class="dropdown">

        </ol>
      </ul>

    <div id="content-div">
      <h2>Computer Security</h2>
      <p>
        Topics include cryptography and computer software that are secure sensitive.
      </p>
      <h3 id="network_security">Network Security</h3>
      <p>The inital network design is <span class="word">end-to-end</span>, which means the devices between two computers are just routers with limited intelligence.
        However, as the network becomes complex, the issue of security also increases significantly.
      </p>
      <ol class="section-list">
        <li>Firewall: like a router to forward packets, but it may deny to forward some packets accroding to a-priori rules by checking headers
          <ol>
            <li>Most firewalls prevent traffic from the outside (incoming traffic)</li>
            <li>Also may prevent inside users to communicate with outside</li>
            <li>Default behavior: deny and provide whitelist</li>
            <li>Sophisticated firewall: (proxy) can check packets' contents.</li>
            <li>Stateful filtering: Dealing with reply message. e.g. client 132.21.3.2:12304 -> www.google.com:80,
              then we rememeber this info and allow www.google.com -> 132.21.3.2:12304</li>
            <li>Circuit-level proxying: standard protocol: SOCKS. Inside the firewall, one socket connects to client, one socket connects to server.
              firewall check and copy data from one socket to another socket.
            </li>
            <li>Application-level proxying: e.g. HTTP proxy.</li>
          </ol>
        </li>
        <li>
          (Network level) Intrusion detection systems (<mark>IDS</mark>): a middle-box device tells us that we are under attacking.
          <ol>
            <li>Decision used to check whether it is an attacking is made on the fly. V.S. firewall policies are pre-determined.
            </li>
            <li>Signature matching: signature is a pattern that matches known bad behavior. Cons 1). Defender must know the attacking before. it won't work for novel attacks. 
              2). Often easy to attack around. If you are unluck to be the first victim. Also, the signature is static and may be known by attacker.</li>
            <li>Anomaly detection: learn pattern of normal behavior. Cons: 1). if the normal behavior is very diverse, then it is hard to detect.
              2). hard to avoid false positive, fn is also unavoidable. 3). adversary can train over time.</li>
              <li>
                Host-based on IDS: look for compromised process or user from within machines.
              </li>
              <li>False Positive: Bad thing: System said you are under attack, but you are actually good.</li>
              <li>False Negative: Bad thing: System said you are good, but you are under attack.</li>
              <li>False Positive + </li>
          </ol>
        </li>
        <li>Base rate problem
          <ol>
            <li>Rare events trigger alarm, but most of these rare events are good. So it induces a high FP.</li>
            <li>So attacker can take this advantage.</li>
            <li>Wagner and Soto mimicry attack: Host-based IDS based on sequence of syscalls</li>
          </ol>
        </li>
        
        <li>Tunneling: Against firewall
          <ol>
            <li>Any data can be transmitted on any channel, if both sides agree.</li>
            <li>e.g. Encapsulate IP packets over ssh connection.</li>
            <li>SSH can be used to tunnel almost any traffic.</li>
          </ol>
        </li>
        <li>
          Malware: Malicious software.(专门用来做坏事的software. some software that have bugs that can be applied by attackers to do bad things are not
          malware.)
          <ol>
            <liT>Trojan (horse木马): looks like benign, e.g. a text editor. But it has malicious purpose. 
              User are fooled to run it.
            </li>
            <li>Computer Virus: a little piece of software that attack to a software to propragate when the attached software run.

            </li>
            <li>Worms: a complete program, completely automatic self-propagation. <mark>Requires remote security holes.</mark></li>
            <li>Rootkit: hide malware by changing the kernel behavior. e.g. ps command will do a malicious thing instead of printing malicious message.</li>
            <li>MBR (master boot record) virus: take control early in boot</li>
            <li>Blue-pill attack: malware is a VM Monitor running your system.</li>
            <li>Why people do malware: 1) curiosity &amp; be famous 2). making money 3). nation-oriented</li>
            <li>Ransomware(勒索软件): encrypt victim's files and let them pay money for decrypting.</li>
          </ol>
        </li>
        <li>
          Bots and botnets
          <ol>
            <li>Bot(肉鸡): program under control of remote attacker</li>
            <li>Botnet: large group of bot-infectde computers with common "master"</li>
            <li>control bot: peer-to-peer &amp; RIC</li>
            <li>Make money fron botnets: 0). click (ad) fraud. 1).distributed DoS, 2).Bitcoin mining 3). Spam sending 4). paid-per-install (租给其他attacker)</li>
          </ol>
        </li>
        <li>
          Anti-virus (AV) systems
          <li>Signatured-based AV: similar idea to signature-based IDS, but it requires a frequently changed database.</li>
          <li>AV software company has research on attacking, keep the database up-to-date.</li>
          <li>Emulation: run an unknown software in a invaluable operating system to see if it does some malicious actions.</li>
          <li>Polymorphism: attackers make a lot of variants of malware, 30 million virus samples observed.</li>
          <li>Packing: static code creates real malicious code on the fly. </li>
          <li>Fake anti-virus: ... 报假警骗钱。</li>
        </li>
        <li>DoS
          <ol>
            <li>Unexpected and unintented by the author.</li>
            <li>Algorithmic complexity attacks: (Developer always care the worst case because they want their systems can always work well). 
              an adversary make your algorithm have the worst-case behavior. e.g. Attacker always let quicksort always be O(n^2).</li>
            <li>XML entity expansion: XML entities (like C macros)</li>
            <li>zip file quine: zip file contains itself, systems recursively unzip file will go to infinite loop.</li>
            <li>DoS against network services:
              <ol>
                <li>making packet small and high sending frequency.</li>
                <li>Queuing Theory: arrival rate >= service rate, request go unbound.</li>
                <li>SYN flooding: syn first of three packets to set up new connection. Server allocates space after receiving first syn. 
                  (CSCI 4211).</li>
                <li>SYN flooding defense: SYN cookies: change server behavior to stateless approach. </li>
                <li>DoS against network links: try to use all availabe bandwidth.</li>
                <li>Traffic multipliers: attacker, victim, third parties(bots) send packets to victim to slow his/her network.</li>
                <li>Distributed Dos: </li>
              </ol>
            </li>
          </ol>
          
        </li>
        
       
      </ol>
      <h3 id="crypto">Cryptography</h3>
      <p>This section introduces the basic concepts of cipher. Following, a couple of popular ciphers are shown.</p>
      <ol class="section-list">
        <li>
          <h4>Concepts</h4>
          <ol class="subsection-list">
            <li>Cipher: an <span class="word">algorithm</span> for performing encryption or decryption.</li>
            <li>cryptography: the study of <span class="word">designing</span> cipher algorithms.</li>
            <li>cryptanalysis: the study of <span class="word">breaking</span> cipher algorithms.</li>
            <li>cryptology: cryptography and cryptanalysis</li>
            <li>Kerckhoffs's principle: [in 19th century] an cipher aglorithm should be secure even if the implementation is public known.
              Modern cryptography embraces openness.</li>
            <li>Symmetric key cryptography: one key for encryption and decryption. The key is secret and shared only by people who should know.</li>
            <li>Public key cryptography: one key for encryption and another key for decryption. Private key is only known by owner, public key can
               be known by anyone. 1). invented in 1970s; 2). Depends on fancier math; 3). Makes key distribution easier.</li>
            <li>Integrity: massage integrity cannot be guaranteed by encryption.</li>
            <li>Secure channel: Using cryptography to construct a secure channel to transmit data securely. e.g. HTTP login, chatting software.
              Consideration: adversary can read and modify ciphertext. So secure channel must deliver message intact and in order.
              Moreover, we must exchange the symmetric key before setting up the secure channel. And we usually use public key cryptography to exchange the symmetric key. And use symmetric key to set
              up the secure channel.
            </li>
            <li>key size: Modern symmetric key size at least 2^128.</li>
            <li>Scenarios of Attacks
              <ol>
                <li>Known ciphertext: a attacker knows ciphertext.</li>
                <li>Known plaintext: a attacker knows a pair of plaintext and ciphertext that used in the past.</li>
                <li>Chosen plaintext: a attacker could choose a plaintext to encrypt and get the ciphertext.</li>
                <li>Chosen ciphertext: a attacker can encrypt any plaintext and decrypt any ciphertext except the one we want to keep secret.</li>
              </ol>
            </li>
            <li>
              Random oracle paradigm: a black box that returns a uniform random number for any different input.
            </li>
            <li>NIST (US National Institute of Standards and Technology): a neutral organization to compete cipher aglorithms in cryptography.</li>
            <li>NSA (National Security Agency): for "signals intelligence"-> getting information from digital signals. Break the encryption of
              everyone in the world. Help US encryption not be broken by foreign powers.</li>
            <li>Stream ciphers (out of fashion): a key used to generate a long pseudorandom bitstream. And then xor with the message.
              <ol>
                <li>+Easy to implement in hardware</li>
                <li>-Stream cipher mutability: a attacker can guess the structure of security data, and modify part of the ciphertext. Then the obtained plaintext
                  will be exactly flipped those bits.
                </li>
              </ol>
            </li>
            <li>Block ciphers: plaintext is divided into fixed length blocks. ciphertext_block = Ciphers(Key, plaintext_block). It is insecure if block size is too small. Current size
              is 128 bits.
              <ol>
                <li>Confusion: combine elements so none can be analyzed individually.</li>
                <li>Diffusion: spread the effect of one symbol around to others. Changing one part, the effect will also be reflected to others.</li>
                <li>Substitution/permutation network (e.g. AES): general structure for building block ciphers. 1). Subsitution: an invertible mod lookup table. 2). Permutation: shuffle bit (diffusion).</li>
              </ol>
            </li>
            <li>
              Mode operation: break a arbitary length of data into blocks, and apply the block cipher. e.g. ECB.
            </li>
            <li>
             stream mode:
            </li>
            <li>
              Birthday paradox: describe that hash function collision is easy to happen. C(n,2 )= n^2, n^2 pairs
            </li>
            <li>
              Birthday attack: find hash function's collision.
            </li>
            <li>Nonce: a value chosen to make a message unique. Used to prevent a reply attack.</li>
          </ol>
        </li>
        <li>
          <h4>Symmetric stream ciphers</h4>
          <ol class="subsection-list">
            <li>
              <h4>Caesar [凯撒] cipher</h4>
              <p>Shift plaintext </p>
            </li>
            <li>
              <h4>Rot-13</h4>
              <p>same as ..</p>
            </li>
            <li>
              <h4>One Time pad (inpractical)</h4>
              <p>A random key whose length is same as the secret message (inpractical). <span class="emphasis">Ciphertext = K xor Plaintext; Plaintext = K xor Ciphertext;</span></p>
            </li>
            <li>
              <h4>RC4</h4>
              <p>Fast, simple, widely used software stream software.</p>
              <p>WEP used RC4 in a wrong way.</p>
            </li>
          </ol>
          </li>
          <li>
          <h4>Mode operation</h4>
          <ol class="subsection-list">
            <li>
              <h4>ECB (Electronic Codebook)</h4>
              <ol>
                <li>Split into blocks and apply cipher to each one individually.</li>
                <li><span class="word">Bad idea: </span> block cipher with a specific key is a deterministic function, y = F(K, x). If two cipherblocks are same, it would mean the corresponding
                  plaintext blocks are also same. (leaking information)
                </li>
                <li>e.g. Image encrypted by DES in ECB mode, you are still find the outline of things in the image.</li>
              </ol>
            </li>
            <li>
              <h4>CBC (Cipher Block Chaining)</h4>
              <ol>
                <li>Ci = Ek(Pi xor Ci-1) // Ek is Encryption(K, x)</li>
                <li>Plaintext changes propagrate forever: If p2 changes, then c2, c3, c4 ... all will change.</li>
                <li>Ciphertext change only two plaintext blocks changed. If c3 changes, then only p4 and p3 change.</li>
                <li>Initialization vector: C0, C0 is not a secret message, but it is randomly generated (nonce: not predicatible)</li>
                <p><img src="./images/cbc-encryption-mode.png" alt="cbc encryption mode" width="450px" height="200px"></p>
              </ol>
            </li>
          </ol>
          </li>
          <li>
          <h4>Stream modes: take a block cipher and a key to generate a key stream and xor with plaintext</h4>
          <ol class="subsection-list">
            <li>
              <h4>OFB (output feedback)</h4>
              <ol>
                <li>Drawback: if key size is small, it may lead collision of keystream. And the ciphertext may be repeated.</li>
                <p>
                  <img src="./images/ofb_mode.png" alt="ofb mode" width="450px" height="200px">
                </p>
              </ol>

            </li>
            <li>
              <h4>CTR (couter mode)</h4>
              <ol>
                <li>Advantage: can start from middle because counter is predicatible.</li>
                <p>
                  <img src="./images/ctr_mode.png" alt="ctr mode" width="450px" height="200px">
                </p>
              </ol>

            </li>
          </ol>
          </li>
          <li>
          <h4>Symmetric block ciphers</h4>
          <ol class="subsection-list">
            <li>
              <h4>AES (advanced encryption standard: very secure)</h4>
              <ol>
                <li><a href="http://www.formaestudio.com/rijndaelinspector/archivos/Rijndael_Animation_v4_eng.swf">Animation</a></li>
                <li>128-bit block, 128/192/256-bit key. Fast software implement, x86 has insns instruction for AES.</li>
                <li>128-bit has 10 round</li>
                <li>The lookup table and mixcolumn's matrix are fixed.</li>
                <li>Round key are expanded by the key schedule. Also use the same lookup table.</li>
              </ol>
            </li>
            <li>
              <h4>DES (data encryption standard: predecessor of AES)</h4>
              <p>Not secure: brute force due to small size of key.</p>
            </li>

            <li>
              <h4>Feistel cipher</h4>
              <p>+ the process as a whole is revertible, even if F is not revertible.</p>
            </li>
          </ol>
        </li>
      </ol>


      <h3>Cryptography Hash functions</h3>

        <p>  Ideal model: take aribitary input return fixed length output. No collision (big output space), not invertible.
          For a cryptography hash function, we don't want the attacker "pre-image" (inversion) this function. i.e. given
          output to find input. Second preimage (targeted collision): finding H(x') == H(x) but x' != x.
        </p>
        <p>If output length is k, preimage and second preimage complex is 2^k, but collision has complexity 2^k/2. </p>
        <p>To avoid collision, be conservative: if input length is about k, then output should be 2 * k.</p>
        <p>History: MD5 (128-bit output: now easy to find collision) ->
          SHA(-0: from NIST/NSA but quickly withdraw) ->
          SHA-1 (small modification 160-bit output, but the real collision is just 2^60 not 2^80, first collision in 2017) ->
          SHA-2 (output 224 256 384 512 bits, still length extension problem) ->
          SHA-3 (fixed length extension in 2015)
        </p>
        <p>Length extension problem (not ideal): hash function (md5 sha-1 sha-2) take fixed lenght input H(A||B) may equal to H(A).</p>


      <h3>Intergrity</h3>
      <p>
      </p>

      <ol class="section-list">
        <li>
            <h4>MAC (message authentication code)</h4>
            <p>Prove the message has not been modified. Input(message, key) = MAC. Receiver use the received message and pre known key to
              recompute the MAC, then compare the two MAC. MAC's kye is usually different from encryption key.
            </p>

        <ol class="subsection-list">
          <li>
            <h4>CBC-MAC</h4>
            <p>CBC-MAC: start VI = 0, to encrypt the message and take the last cipher block as the key.
              For security reason, that we can only use the 0 as VI and last cipher as MAC.
            </p>
          </li>
          <li>
              <h4>HMAC : common</h4>
              <p>
                HMAC: H(K xor a || H(K xor b || MAC)) // using hash function twice.
                H(K || M), H(M || K): insecure due to length extension.
              </p>
          </li>
          <li>
            <h4>How to apply?</h4>
            <p>
              Encrypt and MAC separately. Cipher= Encrypt(K1 , Plain) || MAC(K2, Plain). This is  a bad design
              since encrypt only protect confidentiality and MAC only protect integrity. Therefore, we can use MAC(K2, Plain) to get the plaintext.

            </p>
            <p>
              Encrypt then MAC: has cleanest formal safety proof.
            </p>
            <p>
              First MAC then Encrypt: preferred by practical reasons.
            </p>
        </li>
        <li>
          <h4>GCM (Galois Counter Mode)</h4>
          <p>In traditional encry & Mac authentication, we need to do twice. This is expensive. "Authenticated encryption" modes do both at once.
            Higher preformance. 
          </p>
        </li>
      </ol>
    </li>
    <li>
          <h4>Ordering and message number</h4>
          <p>When sending data, we break them into small packets. Attacker can reorder them, so we assign each one with a sequence number. If we detect out-of-order/duplicated, we just ignore them.
            Sequence number is inside MAC.
          </p>
    </li>
     <li>
          <h4>Padding</h4>
          <p>When the plaintext is not long enough to satisfy the cipher block (e.g. 128-bit). It will be padded with 1, 2,2 ,3,3,3 up to 16 bytes.</p>
          <p>When recover plaintext, decrypt -> remove padding -> compute MAC -> compare MAC </p>
          <p>Padding oracle attack: timing attack: suppose the server's response time depends on whether the padding is correct or not.
            (This assumption is reasonable, because we developer may not compute the MAC when detecting a wrong padding.) By controlling the ciphertext, attacker can modify the padding bytes.

          </p>
    </li>
  </ol>

      <h3>Public key cryptography: generalized block cipher: separate encryption key and decryption key (secret).</h3>
      <p>
        Analogy: Alice wants to send Bob a gift in a locked box. In a symmetric key scenario, both Alice and Bob has the same key. But in public key mode, each person has a private key (key) and a public key
        (lock). The immportant feature of public key is that the physical locks are commute <span class="word">Ek1(Ek2(M)) = Ek2(Ek1(M))</span>.

        </p>
        <p>
        Alice sends this gift and locks it with her lock kA: EkA(gift). Send to Bob. Bob lock it with his lock. EkB(EkA(gift)). Send to Alice.
        Alice unlock her lock. DkA(EkB(EkA(gift))) =  DkA(EkA(EkB(gift))) = EkB(gift). Send to Bob. Bob unlock his lock and get the message.

      </p>
      <p>Modular arithmetic: <a href="https://nrich.maths.org/2200">math</a>
        <ol>
          <li>x = y mod n. Given y and n, we know x. e.g. 10 mod 3 = 1. </li>
          <li>given x and n we cannot know y. e.g. 1 = y mod 3. y = 1, 4, 7 ... </li>
          <li> (g^b (mod p))^a (mod p) = g^ab mod p.</li>
        </ol>

      </p>
      <p>
        Diffie-Hellman key exchange: assumption: we are in a unsecure channel, but we are telling to the right person. Finally, we will reach a final shared key.
        The key is computed on the fly.
        <ol>
          <li>Alice has secret a = 3, Bob has secret b = 4. And two public parameters p = 10 and g = 12.</li>
          <li>Alice -> Bob: A = g^a mod p = 12 ^ 3 mod 10 = 8.</li>
          <li>Bob -> Alice: B = g^b mod p = 12 ^ 4 mod 10 = 6.</li>
          <li>Attacker can capture 8 and 6. However, knowing 8 and 6, the attacker cannot know a and b. since 8 = 12^a mod 10. 12^a has mulitple solution.</li>
          <li>Alice computes B^a mod p = (g^b (mod p))^a (mod p)= 6^3 mod 10 = 6.</li>
          <li>Bob computes A^b mod p = (g^a (mod p))^b (mod p) = 8^4 mod 10 = 6.</li>
          <li>6 is just the secret key.
            Suppose g^b = np + c, then (g^b (mod p))^a (mod p) = c^a mod p.
            And because g^ab mod p = (np + c)^a mod p = c^a mod p. We have (g^b (mod p))^a (mod p) = g^ab mod p.
            We can prove that g^ab mod p == (g^a (mod p))^b (mod p). So (g^a (mod p))^b (mod p) == (g^b (mod p))^a (mod p).
          </li>
        </ol>
      </p>
      <p>
        Public key size must be 10 times larger than security level. (up to 768bits, and usually 2048 bit).
        Elliptic curves: objects from higher math with analogous group structure 2 * security level.
      </p>
      
      <ol class="section-list">
        <li>
          <h4>RSA</h4>
          <ol>
            <li>n = pq two large primes, n is public, p and q are secret. Because n is large, it is hard to guess p and q from n. n (2000 or more bits lang.)
              将两个大质数相乘十分容易，但是想要对其乘积进行因式分解却极其困难.
            </li>
            <li>modular exponentiation - c mod m = (a ⋅ b) mod m, c mod m = [(a mod m) ⋅ (b mod m)] mod m</li>
            <li>choose e and d such that : M^ed mod n = M </li>
            <li>Public key: (n, e); C = M^e mod n (M < n)</li>
            <li>Private key: (n, d); C^d = M^ed mod n = M;</li>
            <li>Euler: ø(n) 与n互质且小于n的数。ø（p）= p - 1 if p is prime.</li>
            <li>随便找一个e < ø(n), and e ø(n)互质</li>
            <li>找 M^ed mod n = M; -> (M^(ed-1) mod n)(M mod n) = M; -> M^(ed - 1) mod n = 1; -> M^(ed-1) = 1 (mod n);</li>
            <li>欧拉定理： a^ø(n) = 1 (mod n); so 找 ed - 1 = ø(n); ø(n) = ø(p * q) = (p -1)*(q -1);</li>
            <li>ed - 1 = (p-1)(q - 1)</li>
            
          </ol>
        </li>
        <li>
          <h4>Hybrid encryption</h4>
          <ol>
            <li>Practical application</li>
            <li>Public-key operations are slow, and complicated.</li>
            <li>Only applied it at the startup time to set up the symmetric session keys.</li>
            <li>So we encrypt session key</li>
          </ol>
        </li>
        <li>
          <h4>Padding: to set the session key</h4>
          <ol>
            <li>public-key encrypted key's size does not match with the key of symmetric encryption scheme.</li>
            <li>PKCS #1 v1.5 suggest padding with 00 01 FF FF ... FF</li>
            <li>But choose ciphertext attacks</li>
            
          </ol>
        </li>
        <li>
          <h4>Modern Padding</h4>
          <ol>
            <li>using hashing, random salt</li>
            <li>OAEP for encryption, PSS for signing</li>

          </ol>
        </li>
        <li>
          <h4>KEM key Encapsulation mechanism</h4>
          <ol>
            <li>
              Instead of we select the session key, choosing it randomly. And hashing the random(r) to get the 256 bits value as
              the session key.
            </li>
            <li>RSA-KEM is insecure if reuse e and r with different n.</li>
        </ol>
        </li>
        <li>
          <h4>Security Properties</h4>
          <ol>
            <li>Non-repudiation: principal cannot later deny having made a commitment :you sign a signature, other people have a copy of that.
              you cannot say you did not sign that later.
            </li>
            <li>Forward secrecy: recovering later information does not reveal past information.
              Why session key: long term key is broken, session key is still ok.
            </li>
            
          </ol>
        </li>
        <li>
          <h4>Replay attack hw example.</h4>
          <ol>
            <li>A nonce is needed to prevent a verbatim replay of a previous message.</li>
            <li>receiver keep track what nonce used before, one nonce can only be used once.</li>
            <li>challenge-response authentication: receiver choose the nonce.</li>
          </ol>
        </li>
        <li>
          <h4>Chess grandmaster problem</h4>
          <ol>
            <li>Variant or dual of MITM: attacker has a different id.</li>
            <li>A and B are chess master. I challenge A and B. A is black chess , B is white chess. A move first, I copy A's move to B. The B response to me,
              I copy B's response to A.</li>
          </ol>
        </li>
        <li>
          <h4>(Public) key distribution</h4>
          <ol>
            <li>Get the correct public key for right person.
            </li>
            <li>Symmetric key servers: users share keys with (trusted) server, server distriuted session keys.
            </li>
            <li>Public key based key distribution. Certificate X.509: A name and a public key signed by someone(ceritficate authority) else. Ca = signByS(A, A-public-key)</li>
            <li>PGP:(poineer of CA, no central server): every is potentially a CA: trust people you know.</li>
          </ol>
        </li>
        <li>
          <ol>
            <h4>CA hierarchies</h4>
            <ol>
             <li>Organize CAs in a tree.</li>
             <li>Enterprise PKI (public key infrastructure) links up with permissions.</li>
             <li>Revocation: 1. short expiration times (bad scalability) 2. certificate revocation lists 2. certificate status online checking API</li>
            </ol>
          </ol>
        </li>
        <li>
          <h4>SSL/TLS</h4>
          <ol>
            <li>Public key for distributing session key and mac key</li>
            <li>
              Developed by netscape SSL1.0 (never released) -> SSL2.0 (one year) -> SSL3.0 (better) -> go to RFC process, renamed to TLS 1.0 -> TLS 1.1, 1.2
              
            </li>
            <li>
              TLS 1.0 use previous the cipher text as the CBC IV (Initilization vector)
            </li>
            <li>
              compression oracle vulnerabilities: compress(S || A), S is secret data, A is attacker-controlled data. If A is similar to S, then then it compresses better.
            </li>

          </ol>
        </li>
      </ol>
      <h3>Signature scheme: generalized MAC: separate signing key (secret) and verification key.</h3>
      <p></p>
      <ol class="section-list">

      </ol>

    </div>
  </body>
</html>
